{"version":3,"sources":["../../../../src/domain/value/String/ImagePath.spec.ts"],"sourcesContent":["import fc from 'fast-check';\nimport { describe, expect, it } from 'vitest';\n\nimport { MAX_IMAGE_PATH_LENGTH } from './BaseString';\nimport { ImagePath } from './ImagePath';\n\ndescribe('ImagePath', () => {\n  it('should return ImagePath when input is valid', () => {\n    fc.assert(\n      fc.property(\n        fc\n          .string({ minLength: 1, maxLength: MAX_IMAGE_PATH_LENGTH })\n          .map((val) => val.trim())\n          .filter((val) => val.length >= 1),\n        (imagePath) => {\n          const value = ImagePath.from(imagePath);\n          expect(value).toBeInstanceOf(ImagePath);\n          expect(value.value).toEqual(imagePath);\n        },\n      ),\n    );\n  });\n  it('should throw an error when input is empty', () => {\n    fc.assert(\n      fc.property(fc.constantFrom('', ' ', '  '), (imagePath) => {\n        expect(() => ImagePath.from(imagePath)).toThrow(\n          'ImagePath must be not empty',\n        );\n      }),\n    );\n  });\n  it('should throw an error when input is too long', () => {\n    fc.assert(\n      fc.property(\n        fc\n          .string({ minLength: MAX_IMAGE_PATH_LENGTH + 1 })\n          .map((val) => val.trim())\n          .filter((val) => val.length > MAX_IMAGE_PATH_LENGTH),\n        (imagePath) => {\n          expect(() => ImagePath.from(imagePath)).toThrow(\n            `ImagePath has maximum length of ${MAX_IMAGE_PATH_LENGTH}`,\n          );\n        },\n      ),\n    );\n  });\n  describe('equals', () => {\n    it('should return true when compare two ImagePath has same value', () => {\n      fc.assert(\n        fc.property(\n          fc\n            .string({ minLength: 1, maxLength: MAX_IMAGE_PATH_LENGTH })\n            .map((val) => val.trim())\n            .filter((val) => val.length >= 1),\n          (imagePath) => {\n            const value1 = ImagePath.from(imagePath);\n            const value2 = ImagePath.from(imagePath);\n            expect(value1).toBeInstanceOf(ImagePath);\n            expect(value2).toBeInstanceOf(ImagePath);\n            expect(value1.value).toEqual(imagePath);\n            expect(value2.value).toEqual(imagePath);\n            expect(value1.equals(value2)).toBe(true);\n          },\n        ),\n      );\n    });\n    it('should return true when compare two ImagePath has difference value', () => {\n      fc.assert(\n        fc.property(\n          fc\n            .record({\n              imagePath1: fc\n                .string({ minLength: 1, maxLength: MAX_IMAGE_PATH_LENGTH })\n                .map((val) => val.trim())\n                .filter((val) => val.length >= 1),\n              imagePath2: fc\n                .string({ minLength: 1, maxLength: MAX_IMAGE_PATH_LENGTH })\n                .map((val) => val.trim())\n                .filter((val) => val.length >= 1),\n            })\n            .filter(({ imagePath1, imagePath2 }) => imagePath1 !== imagePath2),\n          ({ imagePath1, imagePath2 }) => {\n            const value1 = ImagePath.from(imagePath1);\n            const value2 = ImagePath.from(imagePath2);\n            expect(value1).toBeInstanceOf(ImagePath);\n            expect(value2).toBeInstanceOf(ImagePath);\n            expect(value1.value).toEqual(imagePath1);\n            expect(value2.value).toEqual(imagePath2);\n            expect(value1.equals(value2)).toBe(false);\n          },\n        ),\n      );\n    });\n  });\n});\n"],"names":["fc","describe","expect","it","MAX_IMAGE_PATH_LENGTH","ImagePath","assert","property","string","minLength","maxLength","map","val","trim","filter","length","imagePath","value","from","toBeInstanceOf","toEqual","constantFrom","toThrow","value1","value2","equals","toBe","record","imagePath1","imagePath2"],"mappings":"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"}